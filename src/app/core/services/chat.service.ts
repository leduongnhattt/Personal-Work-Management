import { Injectable } from '@angular/core';
import { BehaviorSubject, firstValueFrom } from 'rxjs';
import { ChatMessage } from '../models/chat.model';
import { HttpClient, HttpErrorResponse } from '@angular/common/http';

@Injectable({
  providedIn: 'root'
})
export class ChatService {
  private messagesSubject = new BehaviorSubject<ChatMessage[]>([]);
  messages$ = this.messagesSubject.asObservable();

  private weatherApiKey = '5d9f6620cdf8aac9e4b2e9e532397103';
  private weatherApiUrl = 'https://api.openweathermap.org/data/2.5';

  private knowledgeBase = {
    greetings: {
      patterns: ['xin ch√†o', 'hello', 'hi', 'ch√†o', 'hey'],
      responses: ['Xin ch√†o! T√¥i c√≥ th·ªÉ gi√∫p g√¨ cho b·∫°n?', 'Ch√†o b·∫°n! B·∫°n c·∫ßn t√¥i gi√∫p g√¨ kh√¥ng?']
    },
    thanks: {
      patterns: ['c·∫£m ∆°n', 'thanks', 'thank you'],
      responses: ['Kh√¥ng c√≥ g√¨!', 'R·∫•t vui ƒë∆∞·ª£c gi√∫p b·∫°n!', 'B·∫°n qu√° khen!']
    },
    goodbye: {
      patterns: ['t·∫°m bi·ªát', 'bye', 'goodbye'],
      responses: ['T·∫°m bi·ªát! H·∫πn g·∫∑p l·∫°i!', 'Ch√∫c b·∫°n m·ªôt ng√†y t·ªët l√†nh!']
    },
    weather: {
      patterns: ['th·ªùi ti·∫øt ng√†y h√¥m n√†y', 'th·ªùi ti·∫øt t·∫°i', 'd·ª± b√°o th·ªùi ti·∫øt', 'th·ªùi ti·∫øt tu·∫ßn t·ªõi', 'weather forecast', 'th·ªùi ti·∫øt ·ªü', 'nhi·ªát ƒë·ªô t·∫°i', 'test api', 'ki·ªÉm tra api'],
      responses: async (message: string) => {
        if (message.includes('test') || message.includes('ki·ªÉm tra')) {
          return await this.checkWeatherAPIStatus();
        }
        let city = 'Da Nang';
        if (message.toLowerCase().includes('h√† n·ªôi')) city = 'Hanoi';
        else if (message.toLowerCase().includes('h·ªì ch√≠ minh') || message.toLowerCase().includes('s√†i g√≤n')) city = 'Ho Chi Minh City';
        if (message.toLowerCase().includes('tu·∫ßn') || message.toLowerCase().includes('d·ª± b√°o')) {
          return await this.getWeatherForecast(city);
        }
        return await this.getWeatherInfo(city);
      }
    },
    health: {
      patterns: ['b·∫°n c√≥ kh·ªèe kh√¥ng', 'b·∫°n kh·ªèe kh√¥ng', 'how are you', 'are you ok'],
      responses: ['C·∫£m ∆°n b·∫°n ƒë√£ quan t√¢m! T√¥i l√† m·ªôt tr·ª£ l√Ω ·∫£o n√™n lu√¥n s·∫µn s√†ng gi√∫p ƒë·ª° b·∫°n.', 'T√¥i lu√¥n s·∫µn s√†ng v√† kh·ªèe m·∫°nh ƒë·ªÉ h·ªó tr·ª£ b·∫°n!']
    },
    age: {
      patterns: ['b·∫°n bao nhi√™u tu·ªïi', 'tu·ªïi c·ªßa b·∫°n', 'how old are you'],
      responses: ['T√¥i l√† m·ªôt tr·ª£ l√Ω ·∫£o, tu·ªïi t√°c kh√¥ng quan tr·ªçng b·∫±ng vi·ªác t√¥i c√≥ th·ªÉ gi√∫p g√¨ cho b·∫°n.', 'Tu·ªïi c·ªßa t√¥i kh√¥ng quan tr·ªçng, quan tr·ªçng l√† t√¥i c√≥ th·ªÉ h·ªó tr·ª£ b·∫°n t·ªët nh·∫•t c√≥ th·ªÉ!']
    },
    sovereignty: {
      patterns: ['ho√†ng sa', 'tr∆∞·ªùng sa', 'ch·ªß quy·ªÅn', 'bi·ªÉn ƒë√¥ng', 'sovereignty', 'ho√†ng sa v√† tr∆∞·ªùng sa l√† c·ªßa ai'],
      responses: ['Ho√†ng Sa v√† Tr∆∞·ªùng Sa l√† m·ªôt ph·∫ßn l√£nh th·ªï kh√¥ng th·ªÉ t√°ch r·ªùi c·ªßa Vi·ªát Nam. Vi·ªát Nam c√≥ ƒë·∫ßy ƒë·ªß ch·ª©ng c·ª© l·ªãch s·ª≠ v√† ph√°p l√Ω kh·∫≥ng ƒë·ªãnh ch·ªß quy·ªÅn ƒë·ªëi v·ªõi hai qu·∫ßn ƒë·∫£o n√†y.', 'Ch·ªß quy·ªÅn c·ªßa Vi·ªát Nam ƒë·ªëi v·ªõi Ho√†ng Sa v√† Tr∆∞·ªùng Sa l√† kh√¥ng th·ªÉ tranh c√£i, ƒë∆∞·ª£c x√°c l·∫≠p t·ª´ l√¢u ƒë·ªùi v√† ƒë∆∞·ª£c th·ª±c thi li√™n t·ª•c, h√≤a b√¨nh.']
    }
  };

  constructor(private http: HttpClient) {
    const saved = localStorage.getItem('chatHistory');
    if (saved) {
      const msgs = JSON.parse(saved).map((m: any) => ({ ...m, timestamp: new Date(m.timestamp) }));
      this.messagesSubject.next(msgs);
    }
    this.testWeatherAPI();
  }

  private isGibberish(message: string): boolean {
    const text = message.replace(/\s+/g, '');
    const noVowel = text.length > 3 && !/[aeiouyƒÉ√¢√™√¥∆°∆∞√†√°·∫°·∫£√£·∫ß·∫•·∫≠·∫©·∫´·∫±·∫Ø·∫∑·∫≥·∫µ√®√©·∫π·∫ª·∫Ω·ªÅ·∫ø·ªá·ªÉ·ªÖ√¨√≠·ªã·ªâƒ©√≤√≥·ªç·ªè√µ·ªì·ªë·ªô·ªï·ªó·ªù·ªõ·ª£·ªü·ª°√π√∫·ª•·ªß≈©·ª´·ª©·ª±·ª≠·ªØ·ª≥√Ω·ª∑·ªπƒë]/i.test(text);
    const singleWord = /^[A-Za-z]+$/.test(text) && text.length > 6;
    return noVowel || singleWord;
  }

  async sendMessage(content: string): Promise<void> {
    const userMsg: ChatMessage = { id: this.generateId(), content, sender: 'user', timestamp: new Date(), status: 'sending' };
    this.addMessage(userMsg);

    if (this.isGibberish(content)) {
      this.addMessage({ id: this.generateId(), content: 'B·∫°n c·∫ßn t√¥i gi√∫p g√¨ kh√¥ng?', sender: 'assistant', timestamp: new Date() });
      return;
    }

    try {
      const basic = await this.generateBasicResponse(content);
      if (basic) {
        this.addMessage({ id: this.generateId(), content: basic, sender: 'assistant', timestamp: new Date() });
      } else {
        this.addMessage({ id: this.generateId(), content: 'B·∫°n c·∫ßn t√¥i gi√∫p g√¨ kh√¥ng?', sender: 'assistant', timestamp: new Date() });
      }
    } catch (err) {
      console.error('sendMessage error:', err);
      this.addMessage({ id: this.generateId(), content: 'Xin l·ªói, c√≥ l·ªói x·∫£y ra. Vui l√≤ng th·ª≠ l·∫°i sau.', sender: 'assistant', timestamp: new Date() });
    }
  }

  private async generateBasicResponse(userMessage: string): Promise<string | null> {
    const lower = userMessage.toLowerCase().trim();
    if (this.isTimeQuestion(lower)) return this.getTimeResponse();
    if (this.isDateQuestion(lower)) return this.getDateResponse();
    if (this.isMathQuestion(lower)) return this.solveMathProblem(lower);
    for (const data of Object.values(this.knowledgeBase)) {
      if (data.patterns.some(p => lower.includes(p))) {
        return typeof data.responses === 'function' ? await data.responses(userMessage) : data.responses[Math.floor(Math.random() * data.responses.length)];
      }
    }
    return null;
  }

  private addMessage(message: ChatMessage): void {
    const updated = [...this.messagesSubject.value, message];
    this.messagesSubject.next(updated);
    localStorage.setItem('chatHistory', JSON.stringify(updated));
  }

  private generateId(): string {
    return Math.random().toString(36).substr(2, 9);
  }

  private isTimeQuestion(message: string): boolean {
    return ['m·∫•y gi·ªù', 'gi·ªù m·∫•y', 'th·ªùi gian', 'time', 'hour', 'what time'].some(k => message.includes(k));
  }

  private isDateQuestion(message: string): boolean {
    const lower = message.toLowerCase();
    if (lower.includes('th·ªùi ti·∫øt') || lower.includes('d·ª± b√°o') || lower.includes('nhi·ªát ƒë·ªô')) return false;
    return ['ng√†y m·∫•y', 'th·ª© m·∫•y', 'ng√†y th√°ng', 'date', 'day'].some(k => lower.includes(k)) || (lower.includes('h√¥m nay') && !lower.includes('th·ªùi ti·∫øt'));
  }

  private isMathQuestion(message: string): boolean {
    return ['t√≠nh', 'c·ªông', 'tr·ª´', 'nh√¢n', 'chia', 't·ªïng', 'hi·ªáu', 't√≠ch', 'th∆∞∆°ng', '+', '-', '*', '/', '√ó', '√∑'].some(k => message.includes(k));
  }

  private getTimeResponse(): string {
    const now = new Date();
    return `B√¢y gi·ªù l√† ${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}`;
  }

  private getDateResponse(): string {
    const now = new Date();
    const days = ['Ch·ªß Nh·∫≠t', 'Th·ª© Hai', 'Th·ª© Ba', 'Th·ª© T∆∞', 'Th·ª© NƒÉm', 'Th·ª© S√°u', 'Th·ª© B·∫£y'];
    return `H√¥m nay l√† ${days[now.getDay()]}, ng√†y ${now.getDate()} th√°ng ${now.getMonth() + 1} nƒÉm ${now.getFullYear()}`;
  }

  private solveMathProblem(message: string): string {
    try {
      const nums = message.match(/\d+/g)?.map(Number) || [];
      if (message.includes('+') || message.includes('c·ªông')) return `K·∫øt qu·∫£ l√†: ${nums.reduce((a, b) => a + b, 0)}`;
      if (message.includes('-') || message.includes('tr·ª´')) return nums.length >= 2 ? `K·∫øt qu·∫£ l√†: ${nums[0] - nums[1]}` : 'T√¥i kh√¥ng hi·ªÉu ph√©p t√≠nh n√†y.';
      if (message.includes('*') || message.includes('nh√¢n')) return `K·∫øt qu·∫£ l√†: ${nums.reduce((a, b) => a * b, 1)}`;
      if ((message.includes('/') || message.includes('chia')) && nums[1] !== 0) return `K·∫øt qu·∫£ l√†: ${nums[0] / nums[1]}`;
      const expr = message.match(/[\d+\-*/\s]+/g)?.[0];
      if (expr) return `K·∫øt qu·∫£ l√†: ${eval(expr.replace(/√ó/g, '*').replace(/√∑/g, '/'))}`;
      return 'T√¥i kh√¥ng hi·ªÉu ph√©p t√≠nh n√†y.';
    } catch { return 'Xin l·ªói, t√¥i kh√¥ng th·ªÉ gi·∫£i b√†i to√°n n√†y.'; }
  }

  private async getWeatherInfo(city = 'Da Nang'): Promise<string> {
    try {
      const res = await fetch(`${this.weatherApiUrl}/weather?q=${city}&appid=${this.weatherApiKey}&units=metric&lang=vi`);
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      const d = await res.json();
      const temp = Math.round(d.main.temp);
      const feels = Math.round(d.main.feels_like);
      const humidity = d.main.humidity;
      const desc = d.weather[0].description;
      const wind = Math.round(d.wind.speed * 3.6);
      const name = city === 'Da Nang' ? 'ƒê√† N·∫µng' : city === 'Ho Chi Minh City' ? 'TP. H·ªì Ch√≠ Minh' : 'H√† N·ªôi';
      return `üå§Ô∏è Th·ªùi ti·∫øt t·∫°i ${name}:\nüå°Ô∏è Nhi·ªát ƒë·ªô: ${temp}¬∞C (C·∫£m gi√°c nh∆∞ ${feels}¬∞C)\nüíß ƒê·ªô ·∫©m: ${humidity}%\n‚òÅÔ∏è M√¢y: ${d.clouds.all}%\nüí® Gi√≥: ${wind} km/h\nüìù ${desc}`;
    } catch (e) { console.error(e); return '‚ùå Kh√¥ng th·ªÉ l·∫•y th√¥ng tin th·ªùi ti·∫øt.'; }
  }

  private async getWeatherForecast(city = 'Da Nang'): Promise<string> {
    try {
      const res = await fetch(`${this.weatherApiUrl}/forecast?q=${city}&appid=${this.weatherApiKey}&units=metric&lang=vi`);
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      const d = await res.json();
      const name = city === 'Da Nang' ? 'ƒê√† N·∫µng' : city === 'Ho Chi Minh City' ? 'TP. H·ªì Ch√≠ Minh' : 'H√† N·ªôi';
      const daily = new Map<string, any>();
      for (const it of d.list) {
        const dt = new Date(it.dt * 1000);
        const key = dt.toISOString().split('T')[0];
        if (!daily.has(key)) daily.set(key, { day: ['Ch·ªß Nh·∫≠t', 'Th·ª© Hai', 'Th·ª© Ba', 'Th·ª© T∆∞', 'Th·ª© NƒÉm', 'Th·ª© S√°u', 'Th·ª© B·∫£y'][dt.getDay()], date: `${dt.getDate()}/${dt.getMonth() + 1}`, min: it.main.temp_min, max: it.main.temp_max, desc: it.weather[0].description, hum: it.main.humidity, wind: Math.round(it.wind.speed * 3.6) });
        else {
          const cur = daily.get(key);
          cur.min = Math.min(cur.min, it.main.temp_min);
          cur.max = Math.max(cur.max, it.main.temp_max);
        }
      }
      let out = `üóìÔ∏è D·ª± b√°o 5 ng√†y t·∫°i ${name}:\n\n`;
      let i = 0;
      for (const v of daily.values()) {
        if (i++ === 5) break;
        out += `üìÖ ${v.day} (${v.date}):\nüå°Ô∏è ${Math.round(v.min)}¬∞C - ${Math.round(v.max)}¬∞C\nüíß ${v.hum}%\nüí® ${v.wind} km/h\nüìù ${v.desc}\n\n`;
      }
      return out;
    } catch (e) { console.error(e); return '‚ùå Kh√¥ng th·ªÉ l·∫•y d·ª± b√°o th·ªùi ti·∫øt.'; }
  }

  clearChat(): void {
    this.messagesSubject.next([]);
    localStorage.removeItem('chatHistory');
  }

  async testWeatherAPI() {
    try {
      console.log('Testing weather API...');
      const cur = await firstValueFrom(this.http.get<any>(`${this.weatherApiUrl}/weather`, { params: { q: 'Hanoi', appid: this.weatherApiKey, units: 'metric', lang: 'vi' } }));
      const fc = await firstValueFrom(this.http.get<any>(`${this.weatherApiUrl}/forecast`, { params: { q: 'Hanoi', appid: this.weatherApiKey, units: 'metric', lang: 'vi' } }));
      console.log('Weather:', cur, 'Forecast sample:', fc.list[0]);
    } catch (e) { console.error('API test error:', e); }
  }

  async checkWeatherAPIStatus(): Promise<string> {
    try {
      await firstValueFrom(this.http.get<any>(`${this.weatherApiUrl}/weather`, { params: { q: 'Hanoi', appid: this.weatherApiKey, units: 'metric', lang: 'vi' } }));
      return '‚úÖ API th·ªùi ti·∫øt ho·∫°t ƒë·ªông b√¨nh th∆∞·ªùng';
    } catch (err) {
      if (err instanceof HttpErrorResponse) {
        switch (err.status) {
          case 401: return '‚ùå API Key kh√¥ng h·ª£p l·ªá';
          case 404: return '‚ùå Kh√¥ng t√¨m th·∫•y d·ªØ li·ªáu';
          case 429: return '‚ùå Qu√° gi·ªõi h·∫°n g·ªçi API';
          default: return `‚ùå L·ªói API: ${err.status}`;
        }
      }
      return '‚ùå Kh√¥ng th·ªÉ k·∫øt n·ªëi API th·ªùi ti·∫øt';
    }
  }
}
